local *
local Flag -- `local *` does not cover exports
local Param -- `local *` does not cover exports

EXIT = <tostring>: => "exit"
HELP = <tostring>: => "show help"
USAGE = <tostring>: => "show usage"
VERSION =  <tostring>: => "show version"

export class ArgParser
  new: (@_name) =>
    @_version = nil
    @_flags = {}
    @_params = {}
    @_add_help = true
    @_description = nil
    @_auto_args_added = false

  version: (@_version) => @
  add_arg: (arg) =>
    arg_type = arg.<>?.__class?.__name
    switch arg_type
      when 'Flag'
        @_flags[] = arg
      when 'Param'
        @_params[] = arg
      else
        error "cannot use a #{type arg} as an arg"
    @
  add_param: (param) =>
    param_type = param.<class>.__name
    if param_type != 'Param'
      error "expected Param, got a #{param_type ?? type param}"
    @_params[] = param
    @
  no_help: =>
    @_add_help = false
    @
  description: (@_description) => @

  parse: (args) =>
    ret, err = @_parse args
    if err?
      switch err
        when USAGE
          print @_usage_message!
        when HELP
          print @_help_message!
        when VERSION
          print @_version_message!
        else
          print err
          print @_usage_message!
      return nil, false
    ret, true

  _parse: (args) =>
    if not @_auto_args_added
      @_add_auto_args!
    @_auto_args_added = true

    if err = @_validate!
      return nil, err

    ret = with {}
      for flag in *@_flags
        [flag._name] = flag._default
      for param in *@_params
        [param._name] = param._default

    flag_map = with {}
      for flag in *@_flags
        if flag._short
          [flag._short] = flag
        if flag._long
          [flag._long] = flag

    curr_param = 1
    i = 0
    while i < #args
      i += 1
      arg = args[i]
      if '-' == arg\sub 1, 1
        flag = flag_map[arg]
        if not flag?
          return nil, "unknown flag #{arg}"
        ret[flag._name] = if not flag._takes_param
          true
        else
          i += 1
          flag_arg = args[i]
          if not flag_arg?
            return nil, "flag #{arg} expected an argument"

          if transform = flag._transform
            transformed, err = transform flag_arg
            if err?
              return nil, "cannot parse '#{flag_arg}': #{err}"
            transformed
          else
            flag_arg
      else
        param = @_params[curr_param]
        if not param
          return nil, "unexpected parameter #{arg}"
        ret[param._name] = if transform = param._transform
          transformed, err = transform arg
          if err?
            return nil, "failed to parse #{arg}: #{err}"
          transformed
        else
          arg
        curr_param += 1

    if ret._usage
      return nil, USAGE
    if ret._help
      return nil, HELP
    if ret._version
      return nil, VERSION

    for flag in *@_flags
      if flag._required and not ret[flag._name]
        return nil, "flag #{flag\_repr!} required"
    for param in *@_params
      if param._required and not ret[param._name]
        return nil, "flag #{param\_repr!} required"

    ret, nil

  _add_auto_args: =>
    if @_add_help
      @add_arg with Flag 'help'
        \dest '_usage'
        \description 'print short help'
        \long nil
      @add_arg with Flag 'help'
        \dest '_help'
        \description 'print long help'
        \short nil

    if @_version?
      @add_arg with Flag 'version'
        \dest '_version'
        \description 'print version'
        \short nil

  _validate: =>
    flag_tags = with {}
      for flag in *@_flags
        if [flag._short] or [flag._long]
          return "duplicate flag: #{flag\_repr!}"
        if flag._short
          [flag._short] = true
        if flag._long
          [flag._long] = true

    arg_names = { flag._name, true for flag in *@_flags }
    for param in *@_params
      name = param._name
      if arg_names[name]?
        return "duplicate parameter name: #{name}"
      arg_names[name] = true
    nil

  _usage_message: =>
    table.concat with {'Usage: ', @_name, ' '}
      first_arg = true
      for flag in *@_sorted_flags!
        if not first_arg
          [] = ' '
        first_arg = false

        if not flag._required
          [] = '['
        [] = flag\_repr!
        if flag._takes_param
          [] = ' '
          [] = flag._value_name
        if not flag._required
          [] = ']'

      for param in *@_params
        if not first_arg
          [] = ' '
        first_arg = false

        if not param._required
          [] = '['
        [] = param\_repr!
        if not param._required
          [] = ']'

  _help_message: =>
    usage_message = @_usage_message!
    lines = with {}
      if @_description?
        [] = "#{@_name} - #{@_description}"

      [] = ''
      [] = @_usage_message!

      if #@_params > 0
        [] = ''
        [] = 'Parameters'

        longest_param_repr_len = math.max unpack [ #p\_repr! for p in *@_params ]
        for param in *@_params
          if description = param._description
            repr = param\_repr!
            padding = ' '\rep longest_param_repr_len - #repr
            [] = "#{repr}#{padding} #{description}"
          else
            [] = param\_repr!

      if #@_flags > 0
        [] = ''
        [] = 'Flags'

        longest_flag_repr_len = math.max unpack [ #p\_long_repr! for p in *@_flags ]
        for flag in *@_sorted_flags!
          if description = flag._description
            repr = flag\_long_repr!
            padding = ' '\rep longest_flag_repr_len - #repr
            [] = "#{repr}#{padding} #{description}"
          else
            [] = flag\_long_repr!

    table.concat lines, '\n'

  _sorted_flags: =>
    ret = [ flag for flag in *@_flags ]
    table.sort ret, (flag1, flag2) ->
      name1 = flag1.name\match '[^-]*$'
      name2 = flag2.name\match '[^-]*$'
      name1 <= name2
    ret

  _version_message: =>
    parts = {@_name}
    if @_version?
      parts[] = @_version
    table.concat parts, ' '

export class Flag
  new: (@_name) =>
    @_takes_param = false
    @_default = false
    @_value_name = 'value'
    @_short = '-' .. @_name\sub 1, 1
    @_long = '--' .. @_name\gsub ' ', '-'
    @_required = false
    @_description = nil
    @_transform = nil

  dest: (@_name) => @
  short: (@_short) => @
  long: (@_long) => @
  required: =>
    @_required = true
    @
  description: (@_description) => @
  transform: (@_transform) => @

  takes_param: () =>
    @_takes_param = true
    @
  default: (@_default) =>
    if 'boolean' == type @_default
      error 'boolean default flag arguments not currently supported'
    @takes_param!
    @

  value_name: (@_value_name) => @

  _repr: => @_short or @_long
  _long_repr: =>
    if @_short? and @_long?
      "#{@_short}, #{@_long}"
    else
      @_repr!

export class Param
  new: (@_name) =>
    @_arg_name = nil
    @_required = true
    @_description = nil
    @_transform = nil

  arg_name: (@_arg_name) => @
  default: (@_default) =>
    @_required = false
    @
  description: (@_description) => @
  transform: (@_transform) => @

  _repr: => @_arg_name or @_name
